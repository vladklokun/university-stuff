\documentclass[
  a4paper,
  oneside,
  BCOR = 10mm,
  DIV = 12,
  12pt,
  headings = normal,
]{scrartcl}

%%% Length calculations
\usepackage{calc}
%%%

%%% Support for color
\usepackage{xcolor}
\definecolor{lightblue}{HTML}{03A9F4}
\definecolor{red}{HTML}{F44336}
%%%

%%% Including graphics
\usepackage{graphicx}
%%%

%%% Font selection
\usepackage{fontspec}

\setromanfont{STIX Two Text}[
  SmallCapsFeatures = {LetterSpace = 8},
]

\setsansfont{IBM Plex Sans}[
  Scale = MatchUppercase,
]

\setmonofont{IBM Plex Mono}[
  Scale = MatchUppercase,
]
%%%

%%% Math typesetting
\usepackage{amsmath}
\usepackage{mathtools}

\usepackage{unicode-math}
\setmathfont{STIX Two Math}

\usepackage{IEEEtrantools}
%%%

%%% List settings
\usepackage{enumitem}
\setlist[enumerate]{
  label*      = {\arabic*.},
  left        = \parindent,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}
% List settings for levels 2–4
\setlist[enumerate, 2, 3, 4]{
  label*      = {\arabic*.},
  left        = 0em,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}

\setlist[itemize, 1, 2, 3, 4]{
  label      = {—},
  left        = \parindent,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  itemsep     = 1\baselineskip,
  noitemsep, % override itemsep
}

\setlist[description]{
  font        = {\rmfamily\upshape\bfseries},
  topsep      = 1\baselineskip,
  parsep      = 0\baselineskip,
  itemsep     = 0\baselineskip,
}

%%%

%%% Structural elements typesetting
\setkomafont{pagenumber}{\rmfamily\upshape}
\setkomafont{disposition}{\rmfamily\bfseries}

% Sectioning
\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries\scshape},
]{section}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries\itshape},
]{subsection}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries},
]{subsubsection}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = -0.5em,
  font       = {\normalsize\mdseries\scshape\addfontfeatures{Letters = {UppercaseSmallCaps}}},
]{paragraph}
%%%

%%% Typographic enhancements
\usepackage{microtype}
%%%

%%% Language-specific settings
\usepackage{polyglossia}
\setmainlanguage{ukrainian}
\setotherlanguage{english}
% \setotherlanguage{russian}
%%%

%%% Captions
\usepackage{caption}
\usepackage{subcaption}

%\DeclareCaptionLabelFormat{closing}{#2)}
%\captionsetup[subtable]{labelformat = closing}

%\captionsetup[subfigure]{labelformat = closing}

\captionsetup[table]{
  aboveskip = 0\baselineskip,
  belowskip = 0\baselineskip,
}

\captionsetup[figure]{
  aboveskip = 1\baselineskip,
  belowskip = 0\baselineskip,
}

\captionsetup[subfigure]{
  labelformat = simple,
  labelformat = brace,
  justification = RaggedRight,
  singlelinecheck = false,
}
%%%

%%% Hyphenated ragged typesetting
\usepackage{ragged2e}
%%%

%%% Table typesetting
\usepackage{booktabs}
\usepackage{longtable}

\usepackage{multirow}

\usepackage{array}
\newcolumntype{v}[1]{>{\RaggedRight\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{b}[1]{>{\Centering\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{n}[1]{>{\RaggedLeft\arraybackslash\hspace{0pt}}p{#1}}
%%%

%%% Drawing
\usepackage{tikz}
\usepackage{tikzscale}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usetikzlibrary{positioning}
\usetikzlibrary{patterns}
\usetikzlibrary{intersections}
\usetikzlibrary{arrows.meta} % Stealth arrow tips
\usetikzlibrary{graphs}
% \usetikzlibrary{graphdrawing}
% \usegdlibrary{layered}
\usetikzlibrary{quotes}

\usepackage{pgfplots}
\usepgfplotslibrary{fillbetween}
%%%

%%% SI units typesetting
\usepackage{siunitx}
\sisetup{
  output-decimal-marker = {,},
  exponent-product      = {\cdot},
  inter-unit-product    = \ensuremath{{} \cdot {}},
  per-mode              = symbol,
}
%%%

% Code Highlighting
\usepackage{minted}
\setmintedinline{
  style = bw,
  breaklines,
}

\newminted[bashterm]{text}{%
  autogobble,%
  breaklines,%
  style=bw,%
}

\newminted[codegeneric]{text}{%
  autogobble,%
  style=bw,%
  breaklines,%
  fontsize=\small,%
}

\newmintinline{bash}{%
}

\newmintinline[minttext]{text}{%
  breaklines,%
  breakanywhere,%
}

%%% Framing code listings
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\tcbuselibrary{minted}
\tcbuselibrary{skins}

% Text file listing
\newtcblisting[
  auto counter,
  list inside,
  number within = section,
]{listingplaintext}[3][]{%
  minted language = text,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

\newtcbinputlisting[
  use counter from = listingplaintext,
  list inside,
  number within = section
]{\inputplaintext}[4][]{%
  minted language = text,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #3},
  list entry       = {\protect\numberline{\thetcbcounter}#3},
  left = 0em,
  right = 0em,
  %
  listing file={#2},
  listing only,
  breakable,
  %
  label = {#4}
}

\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingpython}[3][]{%
  minted language = python,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},
  %
  #1%
}

\newtcbinputlisting[
  use counter from = listingplaintext,
  list inside,
  number within = section
]{\inputpython}[4][]{%
  minted language = python,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #3},
  list entry       = {\protect\numberline{\thetcbcounter}#3},
  left = 0em,
  right = 0em,
  %
  listing file={#2},
  listing only,
  breakable,
  %
  label = {#4}
}

% Linux command-line listing
\newtcblisting{linuxterm}%
{%
  % Syntax highlighing options
  listing only,%
  minted language = bash,%
  minted options={%
    autogobble,%
    linenos%
  },%
  % Presentation options
  empty,%
  %% Margins
  sharp corners,%
  toptitle = 0.0em,%
  bottomtitle = 0.0em,%
  left = 0em,%
  right = 0em,%
  before skip = \intextsep,%
  after skip = \intextsep,%
}

\newtcblisting{linuxtermout}%
{%
  % Syntax highlighing options
  listing only,%
  minted language = text,%
  minted options={%
    autogobble,%
    linenos%
  },%
  % Presentation options
  empty,%
  %% Margins
  sharp corners,%
  toptitle = 0.0em,%
  bottomtitle = 0.0em,%
  left = 0em,%
  right = 0em,%
  before skip = \intextsep,%
  after skip = \intextsep,%
}

% Dockerfile listings
\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingdocker}[3][]{%
  minted language = dockerfile,
  minted style    = bw,
  minted options  = {
    autogobble,%
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

% Docker Compose listings
\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingdockercompose}[3][]{%
  minted language = yaml,
  minted style    = bw,
  minted options  = {
    autogobble,%
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

% SWI Prolog listings
\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingprolog}[3][]{%
  minted language = prolog,
  minted style    = bw,
  minted options  = {
    autogobble,%
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

\newtcbinputlisting[
  use counter from = listingplaintext,
  list inside,
  number within = section
]{\inputprolog}[4][]{%
  minted language = prolog,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #3},
  list entry       = {\protect\numberline{\thetcbcounter}#3},
  left = 0em,
  right = 0em,
  %
  listing file={#2},
  listing only,
  breakable,
  %
  label = {#4}
}


% Customize minted line numbers
\renewcommand{\theFancyVerbLine}{\ttfamily\scriptsize\arabic{FancyVerbLine}}

%%%

%%% Algorithms typesetting
\usepackage[
  ruled,
  linesnumbered,
  onelanguage,
]{algorithm2e}

% Change comments font to roman
\newcommand{\mycommfont}[1]{\rmfamily{#1}}
\SetCommentSty{mycommfont}

% Translate keywords into Ukrainian
\makeatletter
\renewcommand{\listalgorithmcfname}{Список алгоритмів}%
\renewcommand{\algorithmcfname}{Алгоритм}%
\renewcommand{\algocf@languagechoosen}{ukrainian}%

\SetKwBlock{Begin}{початок}{кінець}%
\SetKwIF{If}{ElseIf}{Else}{якщо}{то}{інакше якщо}{інакше}{кінець якщо}%
\SetKwFor{While}{поки}{роби}{кінецьпоки}
\makeatother
%%%

%%% Bibliography
\usepackage[
  style    = gost-numeric,
  language = auto,
  autolang = other,
  sorting  = none,
  maxcitenames = 2,
]{biblatex}
\addbibresource{y04s02-decision-theory-homework-01-s02-report-bibliography.bib}
%%%

%%% Links and hyperreferences
\usepackage{hyperref}
\hypersetup{
  bookmarksnumbered = true,
  colorlinks      = false,
  linkbordercolor = red,
  urlbordercolor  = lightblue,
  pdfborderstyle  = {/S/U/W 1.5},
}
%%%

%%% Length adjustment

% Set baselineskip, default is 14.5 pt
\linespread{1.068966} % ~15.5 pt
\setlength{\emergencystretch}{1em}
\setlength{\parindent}{1.5em}
\newlength{\gridunitwidth}
\setlength{\gridunitwidth}{\textwidth / 12}
%%%

%%% Custom commands
\newcommand{\allcaps}[1]{%
  {%
    \addfontfeatures{%
      Letters = UppercaseSmallCaps,
      LetterSpace = 8,%
    }%
    #1%
  }%
}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\progname}[1]{\texttt{#1}}
\newcommand{\commandname}[1]{\texttt{#1}}
\newcommand{\modulename}[1]{\texttt{#1}}
\newcommand{\transeng}[1]{{англ.}~\textit{\textenglish{#1}}}
%%%

%%% Custom math commands
\newcommand{\longvar}[1]{\mathit{#1}}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\matr}[1]{\mathbfit{#1}}

\newcommand{\logequiv}{\mathrel{\Longleftrightarrow}} % Logically equivalent

\newcommand{\ssep}{\mid} % set builder separator

\DeclareMathOperator*{\minimize}{min} % minimize for linear programs
\DeclareMathOperator*{\rand}{rand} % rand()

\DeclarePairedDelimiter{\setpower}{\lvert}{\rvert} % set power
%%%

\begin{document}

\begin{titlepage}
    \begin{center}
      Міністерство освіти і~науки України\\
      Національний авіаційний університет\\
      Факультет кібербезпеки, комп'ютерної та~програмної інженерії\\
      Кафедра комп'ютеризованих систем управління

      \vspace{\fill}
        Домашнє завдання\\
        з~дисципліни «Системи підтримки прийняття рішень»\\
        на~тему «Метод побудови і~аналізу множини Еджворта—Парето»\\

      \vspace{\fill}

      \begin{flushright}
        Виконав:\\
        студент \allcaps{ФККПІ}\\
        групи \allcaps{СП}-425\\
        Клокун В.\,Д.\\
        Перевірила:\\
        Росінська Г.\,П.
      \end{flushright}

      Київ 2020
    \end{center}
  \end{titlepage}

  \tableofcontents

  \clearpage
  \section{Область і~мета застосування}
    Щоб~дослідити метод побудови і~аналізу множини Еджворта—Парето, необхідно зрозуміти, в~яких областях він~застосовується та~які~задачі вирішує. Основна область застосування методу побудови і~аналізу множини Еджворта—Парето~— \emph{багатокритеріальна оптимізація} у~дослідженні операцій та~теорії прийняття рішень. Задачі багатокритеріальної оптимізації зазвичай потребують оптимізувати, тобто мінімізувати або~максимізувати, значення декількох цільових характеристик або~показників ефективності~\cite[42]{ventsel-or}. У~такому випадку зазвичай немає єдиного оптимального розв'язку. Натомість, є~множина альтернативних і~однаково оптимальних розв'язків, але~з~різними компромісами. Метод побудови і~аналізу множини Еджворта—Парето прекрасно описує сам~себе: спочатку знаходять множину оптимальних розв'язків, яка~називається множиною Еджворта—Парето, а~потім кожен елемент цієї множини аналізують; далі на~основі аналізу приймають рішення залежно від~методу аналізу або~побажань особи, що~приймає рішення.

    Розглянемо приклад задачі багатокритеріальної оптимізації. Припустимо, що~особа, яка~приймає рішення, хоче купити оптимальну машину. Кожна машина коштує певну суму~$c$, витрачає деяку кількість палива~$f$ на~\SI{100}{\kilo\metre}, виділяє~$p$~шкідливих викидів у~атмосферу, а~її~зручність можна оцінити значенням~$k$. Як~видно, навіть швидко формулюючи задачу, в~ній~можна виділити цілих 4~критерії ефективності кожного розв'язку. Чим~глибше аналізують задачу, тим~більше критеріїв можна виділити. Особа, що~приймає рішення, має~свої вимоги щодо значень кожного критерію: зменшити вартість~$c$, витрати палива~$f$ та~кількість шкідливих викидів~$p$, при~цьому збільшити значення комфорту~$k$.

  \section{Математична постановка задачі}

    Математично задача багатокритеріальної оптимізації формулюється так:
    \begin{IEEEeqnarray*}{s.l}
      Мінімізувати & \left\{ f_1(\vect{x}), f_2(\vect{x}), \dots, f_k (\vect{x}) \right\}\\
        так, щоб~& \vect{x} \in S_i.
    \end{IEEEeqnarray*}
    Це~означає, що~в~ній~представлені~$k \geqslant 2$ \emph{цільових функцій}~$f_i$, де~$\, i \in \{1, \dots, k\}$, причому~$f_i \colon \mathbb{R}^n \mapsto \mathbb{R}$. Кожна цільова функція~$f_i$ приймає на~вхід \emph{вектор вирішальних змінних} (або~просто \emph{вирішальний вектор})~$\vect{x} = (x_1, x_2, \dots, x_n)^{T}$, а~кожен вектор вирішальних змінних~$\vect{x}$ лежить в~непустій \emph{області допустимих розв'язків} $S \subset \mathbb{R}^n$. Кожному розв'язку відповідає \emph{цільовий вектор}, який складається з~цільових значень, тобто значень функції~$\vect{z} = \vect{f}(\vect{x}) = \left( f_1(\vect{x}), f_2(\vect{x}), \dots, f_k (\vect{x}) \right)^{T}$, тобто цільові вектори є~образом відображення вирішальних векторів. Крім цього, цільові вектори формують множину розв'язків~$Z = \vect{f} (S)$, яка~в~свою чергу є~образом відображення області допустимих значень в~цільовому просторі~\cite[X]{miettinen-moo}.

    \subsection{Еталонні точки}
      Щоб~мати можливість оцінити якість знайдених розв'язків, зазвичай розглядають такі точки в~області значення цільової функції:~\cite[34]{ehrgott-multiopt}\cite[xi]{miettinen-moo}
      \begin{itemize}
        \item ідеальна точка або~ідеальний цільовий вектор~$\vect{z^{*}}$~— визначається як~вектор, кожна з~координат якого має~оптимальне значення відповідної складової цільової функції. Наприклад, якщо оптимальним значенням функції є~мінімум, тоді ідеальна точка визначається так:
          \begin{IEEEeqnarray*}{rCl}
            \vect{z^{*}} = \left( z^{*}_1, \dots, z^{*}_k \right)
                         = \left( \min_{x \in S_i} f_1(\vect{x}), \dots, \min_{x \in S_i} f_k(\vect{x})\right)^{T}.
          \end{IEEEeqnarray*}
        \item утопічна точка або~утопічний цільовий вектор~$\vect{z^{**}}$~— це~вектор, який строго кращий за~ідеальний цільовий вектор~$\vect{z^{*}}$. Його знаходять так:
          \begin{IEEEeqnarray*}{rCl}
            \vect{z^{**}} = \vect{z^{*}} - \varepsilon U.
          \end{IEEEeqnarray*}
          де~$\varepsilon > 0$, а~$U$~— одиничний вектор.
        \item надир~$\vect{z^{\text{nad}}}$~— це~верхня границя множини~Парето. Точка надиру визначається як~вектор:
          \begin{IEEEeqnarray*}{rCl}
            \vect{z^{\text{nad}}} = \left( z^{\text{nad}}_1, \dots, z^{\text{nad}}_k \right)
                         = \left( \max_{x \in S_i} f_1(\vect{x}), \dots, \max_{x \in S_i} f_k(\vect{x})\right)^{T}.
          \end{IEEEeqnarray*}
      \end{itemize}
      Ці~точки дозволяють порівняти певний розв'язок та~оцінити його цінність. У~деяких випадках ці~точки можуть бути розв'язками.

    \subsection{Множина Еджворта—Парето}
      \label{ssec:pareto-set}
      Оцінити якість розв'язків можна не~лише за~допомогою еталонних точок, адже можна перевірити, чи~є~цільовий вектор оптимальним. В~багатокритеріальній оптимізації, цільовий вектор вважають оптимальним, якщо неможливо покращити жодну з~його компонент, не~погіршивши як~мінімум одну іншу. Точніше, вирішальний вектор~$\vect{x'} \in S$ називається \emph{Парето-оптимальним}, якщо не~існує такого іншого вирішального вектора~$\vect{x} \in S$, що~$f_i (\vect{x}) \leqslant f_i (\vect{x'})$ для~усіх~$i \in {1, \dots, k}$ та~$f_j (\vect{x}) < f_j(\vect{x'})$ для~як~мінімум одного індексу~$j$. Кожна задача може мати декілька Парето-оптимальних векторів, або~навіть їх~нескінченно велику кількість. Множина усіх Парето-оптимальних вирішальних векторів називається \emph{множиною Еджворта—Парето}, позначимо її~як~$P(S)$. Відповідно, цільовий вектор вважають оптимальним, якщо відповідний йому вирішальний вектор є~Парето-оптимальним. Тоді множину Парето-оптимальних цільових векторів позначимо як~$P(Z)$.

    \section{Побудова множини Еджворта—Парето}
      Щоб~побудувати множину Еджворта—Парето, існує декілька підходів~\cite{ehlers-pareto-front},~\cite{toth-compute-pareto-set}, які~можуть бути як~наївними, так~і~більш ефективними. Так~як~ефективні методи, зокрема за~допомогою використання функцій пристосованості, заслуговують окремих статей~\cite{songqing-efficient-pareto-set}, а~метою домашнього завдання є~більш детальне дослідження методів аналізу, розглянемо лише наївний метод побудови множини Парето.

      Перш за~все~зазначимо, що~так~як~множина цільових векторів є~образом відображення множини можливих розв'язків, то~наївний алгоритм можна абсолютно аналогічно застосувати і~для~множини цільових векторів. У~цьому прикладі наївний метод розглянутий на~прикладі множини можливих розв'язків.

      Також домовимось про~позначення відношення «менше або~дорівнює» для~векторів. Відношення~$\vect{x} \leqq \vect{x'}$ справедливе тоді і~тільки тоді, коли для~будь-якого значення~$i \in \{1, \dots, k\}$ значення компонент вектора~$x_{i} \leqslant x'_{i}$, причому~$x_{i} \neq x'_{i}$.

      Отже, нехай множина можливих розв'язків~$X$ містить скінченну кількість елементів. Щоб~побудувати множину Еджворта—Парето за~наївним підходом, необхідно дотримуватись таких кроків:
      \begin{enumerate}
        \item Обрати можливий розв'язок~$\vect{x} \in S_i$.
        \item Порівняти його з~усіма іншими можливими розв'язками~$\vect{x'} \in \{ S_i \setminus \vect{x} \}$.
        \item Якщо для~всіх інших можливих розв'язків~$\vect{x'}$ справджується умова~$\vect{x} \leqq \vect{x'}$, вилучаємо обраний можливий розв'язок~$\vect{x}$ і~додаємо його у~множину~Парето–Еджворта~$P(S)$.
        \item Якщо ж~для~обраного розв'язку навпаки справджується умова~$\vect{x'} \leqq \vect{x}$, обраний розв'язок~$\vect{x}$ необхідно видалити з~множини~$S_i$ і~перейти до~наступного можливого розв'язку.
        \item Якщо жодна з~умов не~справдилась, не~потрібно нічого видаляти, а~лише перейти до~наступного елемента в~множині~$S_i$.
      \end{enumerate}
      Інакше кажучи, необхідно перевірити кожен можливий розв'язок~$\vect{x} \in S_i$ на~Парето-оптимальність, як~описано в~підрозділі~\ref{ssec:pareto-set}.

    \section{Аналіз множини Еджворта—Парето}

      Як~зрозуміло з~визначення множини Еджворта—Парето, вона може містити декілька варіантів, які~будуть однаково оптимальними. Тобто особі, що~приймає рішення, все~ще~потрібно буде обрати один варіант серед усіх Парето-оптимальних варіантів. Для~цього призначений другий крок методу~— аналіз множини.

      Існує багато методів аналізу множини Парето, які~часто використовують спільні стратегії, тому їх~відносять до~спільних категорій. В~рамках цих~категорій, методи бувають:
      \begin{itemize}
        \item неінтерактивні,
          \begin{itemize}
            \item базові,
            \item методи, що~не~враховують побажання,
            \item апостеріорні
            \item апріорні,
          \end{itemize}
        \item інтерактивні,
        \item еволюційні.
      \end{itemize}
      Розглянемо ці~категорії детальніше.

      \subsection{Неінтерактивні методи}
        \emph{Неінтерактивні} методи аналізу множини Парето отримали таку назву тому, що~особа, що~приймає рішення, не~бере участь у~процесі пошуку розв'язку.

        \subsubsection{Базові методи}
          Першою підкатегорією неінтерактивних методів є~базові методи, які~зазвичай використовують ідею \emph{скаляризації}: оскільки цільова функція задачі багатокритеріальної оптимізації має~векторні значення, її~перетворюють на~функцію зі~скалярним значенням. Таким чином, задача багатокритеріальної оптимізації зводиться до~задачі оптимізації з~однією скалярною цільовою функцією. Функція скаляризації має~задовільняти нижчезазначеним умовам.

          Нехай~$F$~— функція скаляризації, що~перетворює векторну функцію~$\vect {y} = {\vect {f}} ({\vect {x}})$ на~скалярну. Якщо~$F$ зберігає впорядкованість за~Парето~$\vect {y}$, тобто, якщо для~довільних~${\vect {y}}^{1}, \, {\vect {y}}^{2} \in {\vect {f}}(X)$ виконується:
          \begin{IEEEeqnarray*}{rCl}
            {\vect {y}}^{1}\leq {\vect {y}}^{2}\implies F({\vect {y}}^{1})<F({\vect {y}}^{2}),
          \end{IEEEeqnarray*}
          тоді розв'язок~${\vect {x}}^{0}$, що~мінімізує~$F$ на~$X$ є~розв'язком за~Парето.

          Якщо~$F$ зберігає відношення порядку~$<$ в~${\vect {y}}$, тобто, якщо для~довільних~${\vect {y}}^{1}, \, {\vect {y}}^{2}\in {\vect {f}}(X)$ виконується:
          \begin{IEEEeqnarray*}{rCl}
            {\vect {y}}^{1}<{\vect {y}}^{2}\implies F({\vect {y}}^{1})<F({\vect {y}}^{2}),
          \end{IEEEeqnarray*}
          тоді розв'язок~$\vect {x}^{0}$, що~мінімізує~$F$ на~$X$ є~слабким за~Парето. Якщо~$F$ неперервна на~${\vect {y}}$, та~$\displaystyle {\vect {x}}^{0}$ єдина точка мінімуму~$F$ на~$X$, тоді~$\vect {x}^{0}$ є~розв'язком за~Парето.

          \paragraph{Зважена сума}

            Одним із~інструментів скаляризації є~зважена сума:
            \begin{IEEEeqnarray*}{rCl}
              F_{1}({\vect {f}}({\vect {x}}))=w_{1}f_{1}({\vect {x}})+\dots +w_{r}f_{r}({\vect {x}}).
            \end{IEEEeqnarray*}
            Наведена функція~$F_{1}$ зберігає впорядкованість за~Парето для~$w>0$. Тому розв'язки, що~мінімізують~$F_{1}$ на~$X$ для~довільних~$w>0$ є~оптимальними за~Парето. Однак~$F_{1}$ не~зберігає впорядкованість за~Парето для~$w\geq 0$, а~зберігає лише відношення~$<$ і~тому розв'язки, що~мінімізують~$F_{1}$ на~$X$ для~$w\geq 0$ є~слабкими за~Парето.

            Недоліком методу зважених сум~у~випадку неопуклої множини значень цільових функцій є~неможливість охопити всі~оптимальні за~Парето точки з~множини Парето-фронту.

            У~задачах комбінаторної багатокритеріальної оптимізації множина цільових значень не~є~опуклою, тому метод зважених сум~не~підходить для~скаляризації цільових функцій для~цих~задач.

          \paragraph{Функція скаляризації Чебишева}

            Також для~скаляризації використовують функцію Чебишева:
            \begin{IEEEeqnarray*}{rCl}
              F_{\infty }({\vect {f}}({\vect {x}}))=\max _{1\leq i\leq r}w_{i}f_{i}({\vect {x}}).
            \end{IEEEeqnarray*}
            Зважена функція скаляризації Чебишева зберігає відношення~$<$ і~тому мінімум~$F_{\infty }$ є~слабким за~Парето.


          \paragraph{Метод зміни обмежень ($ε$-обмеження)}

            За~методом зміни обмежень одну з~цільових функцій залишають як~цільову, а~решту перетворюють на~обмеження. Тобто, нехай~$f_{r}$ буде цільовою, а~решта~$f_{1},\dots ,f_{r-1}$ як~обмеження нерівності:
            \begin{IEEEeqnarray*}{rCl}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & f_{r}({\vect {x}}),\\
                так, щоб~    & f_{i}({\vect {x}})\leq \varepsilon _{i},i=1,\dots ,r-1,\\
                             &\vect {x} \in X.
              \end{IEEEeqnarraybox}
            \end{IEEEeqnarray*}
            Значення~$\varepsilon _{1},\dots ,\varepsilon _{r-1}$ можуть розглядатись як~припустимі рівні для~$f_{1},\dots ,f_{r-1}$.

    \subsubsection{Методи, що~не~враховують побажання}
      Як~дає~зрозуміти назва, ці~методи не~враховують побажання особи, що~приймають рішення, у~своїй роботі. Їх~суть полягає в~тому, щоб~знайти певний компромісний розв'язок, зазвичай посередині множини Парето, тому що~під~час~роботи метода немає інформації, яка~б~направляла його до~розв'язків, яким надає перевагу особа, що~приймає рішення. Методи, що~не~враховують побажання, підходять у~випадках, коли немає особи, що~приймає рішення, або~вона не~очікує нічого конкретного від~розв'язків. Також їх~можна застосовувати як~початкову точку для~інтерактивних методів.

      \paragraph{Метод глобального критерію}
        Суть методу глобального критерію в~тому, щоб~мінімізувати відстань між~певною бажаною точкою відліку та~областю допустимих розв'язків. Для~цього аналітик обирає точку відліку і~метрику відстані. Як~точку відліку логічно обрати ідеальну точку~$y^{I}$. Що~до~метрики відстані, то~можна використати метрику~$L_p$ або~метрику Чебишева~$L_{\infty}$. Це~дозволить виміряти відстань до~ідеальної точки~$\vect{z^{*}}$ або~утопічної точки~$\vect{z^{**}}$. Потім, залежно від~обраної метрики, необхідно вирішити таку задачу:
        \begin{IEEEeqnarray*}{rCl}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & \left(
                                 \sum_{i=1}^{k} \left| f_i(\vect{x}) - z^{*}_i \right|
                               \right)^{1/p},\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray*}
        де~показник степеня~$1/p$ можна опустити, або~ж:
        \begin{IEEEeqnarray*}{rCl}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & \max_{i \in \{1, \dots, k\}}
                                 \left[
                                   \left| f_i(\vect{x}) - z^{*}_i \right|
                                 \right],\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray*}
        відповідно. Зазначимо, що~якщо на~цьому етапі відомо значення ідеальної точки, можна ігнорувати оператори модуля, тому що~згідно з~визначенням ідеальної точки, різниця завжди буде додатною.

        Також варто вказати, що~якщо цільові функції мають різні степені, цей~метод правильно спрацює тільки якщо привести цільові функції до~однорідної, безрозмірного діапазону. Це~означає, наприклад, що~треба розділити кожен член зі~значенням модуля, який містить значення~$f_i$, на~відповідний діапазон~$f_i$ у~множині Парето, тобто на~$z_{i}^{\text{nad}} - z_{i}^{**}$ для~кожного значення~$i$. Так~як~утопічна точка домінує над~усіма Парето-оптимальними розв'язками, необхідно використовувати утопічні, а~не~ідеальні цільові значення, щоб~не~ділити на~нуль.

      \paragraph{Нейтральний компромісний розв'язок}
        Іншим простим способом знайти розв'язок без~особи, що~приймає рішення називається \emph{нейтральним компромісним розв'язком}. Його ідея полягає в~тому, щоб~знайти допустиму точку «десь посередині» значень цільових функцій у~множині Парето. Компоненти цієї точки можна знайти як~середнє значення ідеальних або~утопічних векторів та~вектора надиру. Тобто можна знайти нейтральний розв'язок, розв'язавши таку задачу:
        \begin{IEEEeqnarray*}{rCl}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & \max_{i \in \{1, \dots, k\}}
                                 \left[
                                   \frac{f_i(\vect{x}) - \left(
                                     \left(
                                       z_i^{*} + z^{\text{nad}}_i \right) / 2
                                     \right)}
                                   {z^{\text{nad}} - z^{**}_i }
                                 \right],\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray*}
        Як~видно, у~цій~задачі використовується утопічний цільовий вектор та~надир або~інші наближення із~діапазону цільових функцій у~множині Парето, щоб~привести цільові функції до~єдиного діапазону. Такий розв'язок буде слабо Парето-оптимальним. Звісно, можна замінити середнє значення ідеальної точки з~надиром на~середнє значення утопічної точки з~надиром.

    \subsubsection{Апостеріорні методи}
      Щоб~використати апостеріорні методи, необхідна особа, що~приймає рішення. Так~як~може існувати нескінченно багато Парето-оптимальних розв'язків, апостеріорні методи генерують представлення множини Парето та~показують його особі, що~приймає рішення, а~вона обирає те, яке~найбільше її~влаштовує. Ідея в~тому, що~коли особа, що~приймає рішення, побачить представлення різних Парето-оптимальних розв'язків, їй~буде легше прийняти рішення. Недоліки апостеріорних методів у~тому, що~зазвичай вони обчислювально складні, а~також у~тому, що~навіть після того, як~особа, що~приймає рішення, побачить загальний вигляд Парето-оптимальних розв'язків, їй~все~ще~може бути важко обрати один.

      Варто пам'ятати, що~метод зважених сум~та~метод зміни~$\varepsilon$-обмеження можна використати як~апостеріорні методи. Але~зараз розглянемо традиційні методи цього класу.

      \paragraph{Метод зважених метрик}
        Метод зважених метрик\footnote{Іноді його також називають компромісним програмуванням.} ототожнює ідею метода глобального критерію, в~якому мінімізується відстань між~певною точкою відліку та~областю допустимих розв'язків. Різниця в~тому, що~зважуючи метрики відстані, можна отримувати різні розв'язки.

        Як~і~у~методі глобального критерію, знайдений розв'язок сильно залежить від~використаної метрики відстані. У~випадку, коли~$1 \leqslant p \leqslant \infty$, задача формулюється так:
        \begin{IEEEeqnarray}{rCl}
          \label{eqn:weighted-metric-problem-01}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & \left(
                                 \sum_{i=1}^{k} w_i
                                 \left( f_i(\vect{x}) - z^{*}_i \right)^p
                               \right)^{1/p},\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray}
        де~показник степеня~$1/p$ можна опустити. Або~ж~можна сформулювати~\emph{зважену за~Чебишевим задачу}:
        \begin{IEEEeqnarray}{rCl}
          \label{eqn:weighted-metric-problem-02}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & \max_{i \in \{1, \dots, k\}}
                                 \left[
                                   w_i
                                   \left( f_i(\vect{x}) - z^{*}_i \right)
                                 \right],\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray}
        Зазначимо, що~припускаючи, що~при~розв'язку задачі відомий глобальний ідеальний або~утопічний вектор, ми~ігноруємо абсолютні значення. Що~стосується оптимальності, можна довести, що~розв'язок задачі~\eqref{eqn:weighted-metric-problem-01} є~Парето-оптималььним, якщо він~унікальний, або~якщо усі~ваги додатні. Також, розв'язок задачі~\eqref{eqn:weighted-metric-problem-02} є~слабко Парето-оптимальним, якщо ваги додатні, а~ще~ця~задача має~як~мінімум один Парето-оптимальний розв'язок. Тим~не~менш, щоб~довести, що~змінюючи значення ваг~у~задачі~\eqref{eqn:weighted-metric-problem-01}, можна знайти усі~Парето-оптимальні розв'язки, необхідно, щоб~задача була опуклою. Натомість, розв'язуючи задачу~\eqref{eqn:weighted-metric-problem-02}, можна знайти будь-яке~Парето-оптимальне значення, якщо використовувати утопічний цільовий вектор як~точку відліку.

      \paragraph{Використання функції скаляризації досягнення}
        Існують особливі скаляризаційні функції, які~називаються \emph{функціями скаляризації досягнень} або~просто~\emph{функціями досягнень}. Вони опираються на~певну довільну точку відліку~$\bar{\vect{z}} \in \mathbb{R}^k$. Ідея їх~застосування полягає в~тому, щоб~відобразити точку відліку, яка~містить бажані рівні досягнень, на~множину Парето. Використовуючи різні точки відліку, отримують різні Парето-оптимальні розв'язки. Цей~метод відрізняється від~методу зважених метрик тим, що~він~не~використовує метрики відстані, а~точка відліку не~обов'язково має~бути ідеальним або~утопічним цільовим вектором. Завдяки цим~властивостям, метод знаходить Парето-оптимальні розв'язки незалежно від~того, як~обирають точку відліку.

    \subsubsection{Апріорні методи}
      \emph{Апріорні методи} отримали таку назву, тому що~особа, яка~приймає рішення, повинна зазначити інформацію про~свої побажання до~початку пошуку розв'язку. Якщо розв'язок задовольняє особу, яка~приймає рішення, їй~не~потрібно витрачати багато час~на~власне процес розв'язку. Однак, на~жаль, особа, яка~приймає рішення, часто не~знає, на~який розв'язок можна очікувати та~наскільки реалістичні її~очікування. В~такому випадку особа, що~приймає рішення, може бути розчарована знайденим розв'язком там~може бути готовою змінити свої побажання. Також зазначимо, що~вищеописані методи також можна використати як~апріорні, і~розглянемо власне апріорні методи.

      \paragraph{Метод оцінюючої функції}
        Якщо особа, яка~приймає рішення, знає явну математичну формулу~$v(x)$, яка~виражає усі~її~побажання, їй~прекрасно підійде \emph{метод оцінюючої функції}, адже в~такому випадку можна сформулювати задачу так:
        \begin{IEEEeqnarray*}{rCl}
          \label{eqn:weighted-metric-problem-02}
              \begin{IEEEeqnarraybox}[
              ][c]{s.l}
                Мінімізувати & v(\vect{f}(\vect{x})),\\
                так, щоб~    & \vect {x} \in S_i.
              \end{IEEEeqnarraybox}
        \end{IEEEeqnarray*}
        Так~як~оцінююча функція повністю надає повне упорядкування в~області цільових значень, таким способом можна знайти найкращий Парето-оптимальний розв'язок. На~жаль, дуже важко або~навіть неможливо знайти ту~саму явно математичну формулу~$v(x)$, або~ж~навіть якщо таку функцію знайшли, вона може бути дуже складною і~її~може бути складно оптимізувати. Крім того, навіть якщо особа, яка~приймає рішення, змогла виразити свої побажання у~вигляді оцінюючої функції, отримана структура побажань може бути занадто спрощеною, оскільки оцінюючі функції не~можуть передати несумісність та~інтранзитивність. Інакше кажучи, побажання особи, яка~приймає рішення, повинні відповідати певним вимогам, щоб~для~них~можна було визначити оцінюючу функцію.

      \paragraph{Метод лексикографічного упорядкування}
        Щоб~застосувати метод лексикографічного упорядкування, особа, яка~приймає рішення, має~упорядкувати цільові функції за~їх~абсолютною важливістю. Це~означає, що~більш важлива ціль нескінченно більш важлива, ніж~менш важлива ціль. Після упорядкування спочатку мінімізується найбільш важлива цільова функція, дотримуючись початкових обмежень. Якщо ця~задача має~унікальний розв'язок, він~остаточний і~процес розв'язання завершується. Інакше, вводять нове обмеження, яке~гарантує, що~найважливіша функція збереже своє оптимальне значення, а~потім мінімізують наступну за~важливістю цільову функцію. Якщо наступна функція має~унікальний розв'язок, процес розв'язання закінчується. Інакше ж~він~продовжується за~вищеописаними кроками.

        Варто зазначити, що~перевірити, чи~є~розв'язок унікальним~— обчислювально нетривіальна задача, тому щоб~впевнитись, необхідно розв'язати задачу оптимізації наступної функції. Тоді якщо виявиться, що~наступна задача має~унікальний розв'язок, стає зрозумілим, що~початкова задача обчислювально погано сформульована.

        Можна довести, що~розв'язок за~лексикографічним порядком є~Парето-оптимальним. Цей~метод дуже простий, і~можна сказати, що~люди часто приймають рішення по~порядку. Однак, особі, яка~приймає рішення, може бути складно упорядкувати цілі в~абсолютному порядку важливості. Крім цього, цей~метод дуже грубий, і~досить ймовірно, що~процес розв'язання закінчиться до~того, як~будуть розглянуті менш важливі цілі. Це~означає, що~під~час~розв'язку можуть розглядатись не~усі~цілі, які~були сформульовані у~задачі, що~проблематично.

    \subsection{Інтерактивні методи}
      В~інтерактивних методах особа, яка~приймає рішення, грає важливу роль у~процесі розв'язання, і~ідея цих~методі в~полягає в~тому, щоб~підтримувати особу у~процесі розв'язання. В~інтерактивних методах повторюються кроки ітеративного алгоритму розв'язання, а~особа, яка~приймає рішення, поступово надає інформацію про~свої побажання, щоб~знайти найбільш підходящий розв'язок.

      Залежно від~способу надання інформації про~побажання, інтерактивні методи можуть бути засновані на~інформації про~недоліки, точки відліку або~на~класифікації цільових функцій. Загалом, інтерактивні методи досить складні у~розумінні і~є~відносно новими, тому виходять за~рамки даного домашнього завдання.

    \subsection{Еволюційні методи}
      Еволюційні методи оптимізації істотно відрізняються від~класичних методів. По-перше, процедури еволюційної оптимізації зазвичай не~використовують інформацію про~градієнт під~час~пошуку, тому методи еволюційної оптимізації~— це~методи прямого пошуку, що~дозволяє використовувати їх~у~найрізноманітніших задачах оптимізації. Тим~не~менш, ця~властивість також означає, що~методи еволюційної оптимізації можуть поступатись градієнтним методам у~більш структурованих задачах на~кшталт опуклого, лінійного або~квадратичного програмування.

      По-друге, еволюційні методи використовують більш ніж~один розв'язок за~ітерацію, тобто використовують \emph{популяційний підхід}. Це~дає~декілька переваг:
      \begin{itemize}
        \item обчислення, необхідні для~методів еволюційної оптимізації, можна виконувати паралельно;
        \item методи еволюційної оптимізації можуть знаходити одразу декілька оптимальних розв'язки, що~сприяє розв'язку задач багатокритеріальної оптимізації;
        \item методи еволюційної оптимізації використовують стохастичні оператори, на~відміну від~детермінованих операторів, які~використовуються у~класичних задачах оптимізації. Зазвичай такі оператори використовують упереджені ймовірнісні розподіли, щоб~досягти бажаного результату, що~дозволяє еволюційним алгоритмам краще досягати оптимумів, а~також надає їм~глобальну перспективу задачі.
      \end{itemize}
      Методи еволюційної оптимізації можна описати простим алгоритмом~(алгоритм~\ref{alg:01-evo}).

      \begin{algorithm}
        \SetKwFunction{Initialization}{Ініціалізувати}
        \SetKwFunction{Termination}{ДосягнутийКінець}
        \SetKwFunction{Selection}{Відібрати}
        \SetKwFunction{Evaluation}{Оцінити}
        \SetKwFunction{Variation}{Різноманітнити}
        \SetKwFunction{Elitism}{ЗалишитиНайкращих}
        %
        \caption{Загальний вигляд еволюційного алгоритму}
        \label{alg:01-evo}
        $t = 0$\;
        \Initialization{$P_t$}\;
        \While{$\Termination{$P_t, P_{t+1}$} = 0$}{
          \Evaluation{$P_t$}\;
          $P'_t$ $\coloneqq$ \Selection{$P_t$}\;
          $P''_t$ $\coloneqq$ \Variation{$P'_t$}\;
          $P_{t + 1}$ $\coloneqq$ \Elitism{$P_t$, $P''_t$}\;
          $t \coloneqq t + 1$\;
        }
      \end{algorithm}

      У~наведеному алгоритмі процедура~$\Initialization$ ініціалізує початкову популяцію випадковими значеннями із~області допустимих. Після ініціалізації починається еволюційне моделювання: процедура~$\Termination$ перевіряє, чи~досягнутий кінець на~даному етапі. Якщо ні, то~процедура~$\Evaluation$ оцінює поточну популяцію. В~контексті багатокритеріальної оптимізації це~означає, що~вона обчислює значення цільових функцій для~поточної популяції. Коли особини популяції оцінені, процедура~$\Selection$ відбирає найкращі особини. Далі залишившихся найкращих особин в~популяції змінюють за~допомогою процедури~$\Variation$, відбуваються мутації за~правилами конкретного алгоритму. Після зміни найкращих особин процедура~$\Elitism$ обирає найкращих серед них~та~попередньої популяції та~об'єднує залишившихся в~нову єдину популяцію, і~в~кінці кінців збільшується лічильник ітерацій, а~процес повторюється знову.


  % Conclusions
  \clearpage
  \section{Висновки}
  \addcontentsline{toc}{section}{Висновки}
    Виконуючи дане домашнє завдання, ми~ознайомились із~застосуванням методом побудови і~аналізу множини Еджворта—Парето до~задач прийняття рішень. Користь метода полягає в~тому, що~спочатку він~допомагає побудувати множину дійсно оптимальних рішень, які~неможливо змінити, не~втративши оптимальність. Ця~множина називається множиною Еджворта—Парето. Побудувавши множину, особа, що~приймає рішення, отримує багато оптимальних рішень. Однак, найчастіше за~все~необхідно обрати лише одне.

    Тому метод переходить до~наступного кроку~— аналізу побудованої множини. Існує багато методів аналізу множини, однак їх~можна розподілити за~категоріями. Розрізняють \emph{неінтерактивні}, \emph{інтерактивні} та~\emph{еволюційні} методи. Перші дві~категорії методів звертають увагу на~те, чи~приймає особа, яка~приймає рішення, участь у~процесі пошуку єдиного оптимального розв'язку. Якщо не~приймає, метод вважається неінтерактивним; якщо ж, навпаки, приймає, метод вважають інтерактивним.

    Неінтерактивні методи досить прості, але~також поділяються на~підкатегорії. Перша підкатегорія~— це~\emph{базові методи}, які~зазвичай намагаються перейти від~задачі багатокритеріальної оптимізації до~задачі однокритеріальної оптимізації. Друга підкатегорія~— \emph{методи, які~не~враховують побажання}. Такі методи ігнорують побажання особи, яка~приймає рішення, і~намагаються знайти компроміс, «середнє» значення. Не~варто сприймати як~недолік той~факт, що~метод не~бере до~уваги побажання особи, яка~приймає рішення; навпаки, це~варто сприймати як~перевагу, коли особа, яка~приймає рішення, недоступна або~не~може сформулювати свої побажання. Третя підкатегорія~— це~\emph{апостеріорні методи}, які~передбачають, що~особа, яка~приймає рішення, обере розв'язок після того, як~закінчиться процес розв'язання. Протилежною до~апостеріорних методів є~четверта підкатегорія~— \emph{апріорні методи}, розрахована на~те, що~спочатку особа, яка~приймає рішення, вкаже, якими повинні бути розв'язки, а~вже~потім метод почне розв'язувати задачу.

    Отже, неінтерактивні методи варто використовувати, коли за~тих~чи~інших причин треба зменшити участь особи, яка~приймає рішення, у~процесі, коли неможливо чітко виділити побажання або~коли не~важлива велика точність розв'язків.

    Складнішою є~категорія інтерактивних методів. Вона передбачає, що~особа, яка~приймає рішення, також приймає активну участь у~процесі розв'язку задачі. Це~означає, що~процес роботи методу ітеративний: на~кожній ітерації метод знаходить розв'язок і~презентує його особі, яка~приймає рішення, а~вона натомість вказує свої побажання щодо наступної ітерації розв'язку. Інтерактивні методи шукають розв'язки на~основі інформації про~недоліки кожного розв'язку, позиції відносно певної точки відліку або~класифікації цільової функції, яку~вводить особа, що~приймає рішення.

    Це~означає, що~інтерактивні методи варто використовувати, коли є~відносно чіткі вимоги до~бажаних розв'язків або~коли особа, яка~приймає рішення, бажає приймати активну участь у~процесі розв'язку, щоб~мати чітке представлення про~їх~поточний стан.

    Найновішою, найскладнішою та~найефективнішою є~категорія еволюційних методів. Вони надихаються процесом природного відбору і~намагаються імітувати його при~пошуку розв'язків поставленої задачі. Імітація полягає в~тому, що~алгоритм починає зі~створення певної популяції розв'язків, яку~він~потім оцінює, змінює і~відбирає з~неї~найкращих до~тих~пір, поки не~досягне умови завершення відбору, тобто знайде оптимальний розв'язок. Такий підхід дозволяє не~тільки розв'язувати задачу, одночасно дивлячись на~глобальний простір розв'язків, але~й~пришвидшити процес, виконуючи обчислення паралельно.

    Еволюційні методи дають нову перспективу у~розв'язку задач багатокритеріальної оптимізації і~дозволяють ефективно розв'язувати їх~на~обчислювальних кластерах, а~також досить швидко моделювати цілі популяції розв'язків і~ефективно справлятись із~нечіткими вимогами, однак більш-менш чітким знанням про~бажану популяцію.

  % Bibliography
  \clearpage
  \addcontentsline{toc}{section}{Література}
  \printbibliography

\end{document}
