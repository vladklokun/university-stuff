\documentclass[
  a4paper,
  oneside,
  BCOR = 10mm,
  DIV = 12,
  12pt,
  headings = normal,
]{scrartcl}

%%% Length calculations
\usepackage{calc}
%%%

%%% Support for color
\usepackage{xcolor}
\definecolor{lightblue}{HTML}{03A9F4}
\definecolor{red}{HTML}{F44336}
%%%

%%% Including graphics
\usepackage{graphicx}
%%%

%%% Font selection
\usepackage{fontspec}

\setromanfont{STIX Two Text}[
  SmallCapsFeatures = {LetterSpace = 8},
]

\setsansfont{IBM Plex Sans}[
  Scale = MatchUppercase,
]

\setmonofont{IBM Plex Mono}[
  Scale = MatchUppercase,
]
%%%

%%% Math typesetting
\usepackage{amsmath}

\usepackage{unicode-math}
\setmathfont{STIX Two Math}

\usepackage{IEEEtrantools}
%%%

%%% List settings
\usepackage{enumitem}
\setlist[enumerate]{
  label*      = {\arabic*.},
  left        = \parindent,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}
% List settings for levels 2–4
\setlist[enumerate, 2, 3, 4]{
  label*      = {\arabic*.},
  left        = 0em,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}

\newlist{hangenumerate}{enumerate}{5}
\setlist[hangenumerate, 1, 2, 3, 4, 5]{
  label*      = {\arabic*.},
  leftmargin = 0em,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}

\setlist[itemize]{
  label*      = {—},
  left        = \parindent,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  itemsep     = 1\baselineskip,
  noitemsep, % override itemsep
}

\newlist{hangitemize}{itemize}{5}
\setlist[hangitemize, 1, 2, 3, 4, 5]{
  label*      = {—},
  leftmargin  = 0em,
  topsep      = 0\baselineskip,
  parsep      = 0\baselineskip,
  noitemsep, % override itemsep
}

\newlist{litlist}{enumerate}{1}
\setlist[litlist]{
  label* = {\arabic*.},
  left = 0em,
}

\setlist[description]{
  font        = {\rmfamily\upshape\bfseries},
  topsep      = 1\baselineskip,
  parsep      = 0\baselineskip,
  itemsep     = 0\baselineskip,
}

%%%

%%% Structural elements typesetting
\setkomafont{pagenumber}{\rmfamily\upshape}
\setkomafont{disposition}{\rmfamily\bfseries}

% Sectioning
\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries\scshape},
]{section}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries\itshape},
]{subsection}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = 1\baselineskip,
  font       = {\normalsize\bfseries},
]{subsubsection}

\RedeclareSectionCommand[
  beforeskip = -1\baselineskip,
  afterskip  = -0.5em,
  font       = {\normalsize\mdseries\scshape\addfontfeatures{Letters = {UppercaseSmallCaps}}},
]{paragraph}
%%%

%%% Typographic enhancements
\usepackage{microtype}
%%%

%%% Language-specific settings
\usepackage{polyglossia}
\setmainlanguage{ukrainian}
\setotherlanguages{english}
%%%

%%% Captions
\usepackage{caption}
\usepackage{subcaption}

%\DeclareCaptionLabelFormat{closing}{#2)}
%\captionsetup[subtable]{labelformat = closing}

%\captionsetup[subfigure]{labelformat = closing}

\captionsetup[table]{
  aboveskip = 0\baselineskip,
  belowskip = 0\baselineskip,
}

\captionsetup[figure]{
  aboveskip = 1\baselineskip,
  belowskip = 0\baselineskip,
}

\captionsetup[subfigure]{
  labelformat = simple,
  labelformat = brace,
  justification = RaggedRight,
  singlelinecheck = false,
}
%%%

%%% Hyphenated ragged typesetting
\usepackage{ragged2e}
%%%

%%% Table typesetting
\usepackage{booktabs}
\usepackage{longtable}

\usepackage{multirow}

\usepackage{array}
\newcolumntype{v}[1]{>{\RaggedRight\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{b}[1]{>{\Centering\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{n}[1]{>{\RaggedLeft\arraybackslash\hspace{0pt}}p{#1}}
%%%

%%% Drawing
\usepackage{tikz}
\usepackage{tikzscale}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usetikzlibrary{positioning}
\usetikzlibrary{patterns}
\usetikzlibrary{intersections}
\usetikzlibrary{arrows.meta} % Stealth arrow tips
\usetikzlibrary{graphs}
% \usetikzlibrary{graphdrawing}
% \usegdlibrary{trees}
\usetikzlibrary{quotes}

\usepackage{pgfplots}
\usepgfplotslibrary{fillbetween}
%%%

%%% SI units typesetting
\usepackage{siunitx}
\sisetup{
  output-decimal-marker = {,},
  exponent-product      = {\cdot},
  inter-unit-product    = \ensuremath{{} \cdot {}},
  per-mode              = symbol,
}
%%%

% Code Highlighting
\usepackage{minted}
\setmintedinline{
  style = bw,
  breaklines,
}

\newminted[bashterm]{text}{%
  autogobble,%
  breaklines,%
  style=bw,%
}

\newminted[codegeneric]{text}{%
  autogobble,%
  style=bw,%
  breaklines,%
  fontsize=\small,%
}

\newmintinline{bash}{%
}

\newmintinline[minttext]{text}{%
  breaklines,%
  breakanywhere,%
}

%%% Framing code listings
\usepackage{tcolorbox}
\tcbuselibrary{breakable}
\tcbuselibrary{minted}
\tcbuselibrary{skins}

% Text file listing
\newtcblisting[
  auto counter,
  list inside,
  number within = section,
]{listingplaintext}[3][]{%
  minted language = text,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

\newtcbinputlisting[
  use counter from = listingplaintext,
  list inside,
  number within = section
]{\inputplaintext}[4][]{%
  minted language = text,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #3},
  list entry       = {\protect\numberline{\thetcbcounter}#3},
  left = 0em,
  right = 0em,
  %
  listing file={#2},
  listing only,
  breakable,
  %
  label = {#4}
}

\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingpython}[3][]{%
  minted language = python,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},
  %
  #1%
}

\newtcbinputlisting[
  use counter from = listingplaintext,
  list inside,
  number within = section
]{\inputpython}[4][]{%
  minted language = python,
  minted style    = bw,
  minted options  = {
    autogobble,
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #3},
  list entry       = {\protect\numberline{\thetcbcounter}#3},
  left = 0em,
  right = 0em,
  %
  listing file={#2},
  listing only,
  breakable,
  %
  label = {#4}
}

% Linux command-line listing
\newtcblisting{linuxterm}%
{%
  % Syntax highlighing options
  listing only,%
  minted language = bash,%
  minted options={%
    autogobble,%
    linenos%
  },%
  % Presentation options
  empty,%
  %% Margins
  sharp corners,%
  toptitle = 0.0em,%
  bottomtitle = 0.0em,%
  left = 0em,%
  right = 0em,%
  before skip = \intextsep,%
  after skip = \intextsep,%
}

\newtcblisting{linuxtermout}%
{%
  % Syntax highlighing options
  listing only,%
  minted language = text,%
  minted options={%
    autogobble,%
    linenos%
  },%
  % Presentation options
  empty,%
  %% Margins
  sharp corners,%
  toptitle = 0.0em,%
  bottomtitle = 0.0em,%
  left = 0em,%
  right = 0em,%
  before skip = \intextsep,%
  after skip = \intextsep,%
}

% Dockerfile listings
\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingdocker}[3][]{%
  minted language = dockerfile,
  minted style    = bw,
  minted options  = {
    autogobble,%
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}

% Docker Compose listings
\newtcblisting[
  use counter from = listingplaintext,
  list inside,
  number within = section,
]{listingdockercompose}[3][]{%
  minted language = yaml,
  minted style    = bw,
  minted options  = {
    autogobble,%
    linenos,
    tabsize = 4,
    breaklines,
    breakanywhere,
    fontsize = \footnotesize,
  },
  empty,
  sharp corners,
  coltitle = black,
  borderline horizontal = {1pt}{0pt}{black},
  titlerule = {0.5pt},
  titlerule style = {
    black,
  },
  toptitle = 0.3em,
  bottomtitle = 0.3em,
  before skip      = \intextsep,
  after  skip      = \intextsep,
  title            = {Лістинг \thetcbcounter: #2},
  list entry       = {\protect\numberline{\thetcbcounter}#2},
  left = 0em,
  right = 0em,
  %
  listing only,
  breakable,
  %
  label = {#3},%
}


% Customize minted line numbers
\renewcommand{\theFancyVerbLine}{\ttfamily\scriptsize\arabic{FancyVerbLine}}

%%%

%%% Typeset menus and keys
\usepackage{menukeys}[
  os=win,
]
%%%

%%% Links and hyperreferences
\usepackage{hyperref}
\hypersetup{
  bookmarksnumbered = true,
  colorlinks      = false,
  linkbordercolor = red,
  urlbordercolor  = lightblue,
  pdfborderstyle  = {/S/U/W 1.5},
}
%%%

%%% Length adjustment

% Set baselineskip, default is 14.5 pt
\linespread{1.068966} % ~15.5 pt
\setlength{\emergencystretch}{1em}
\setlength{\parindent}{1.5em}
\newlength{\gridunitwidth}
\setlength{\gridunitwidth}{\textwidth / 12}
%%%

%%% Custom commands
\newcommand{\allcaps}[1]{%
  {%
    \addfontfeatures{%
      Letters = UppercaseSmallCaps,
      LetterSpace = 8,%
    }%
    #1%
  }%
}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\progname}[1]{\texttt{#1}}
\newcommand{\commandname}[1]{\texttt{#1}}
\newcommand{\modulename}[1]{\texttt{#1}}
\newcommand{\transeng}[1]{{англ.}~\textit{\textenglish{#1}}}
%%%

%%% Custom math commands
\newcommand{\longvar}[1]{\mathit{#1}}
\newcommand{\vect}[1]{\mathbfit{#1}}
\newcommand{\matr}[1]{\mathbfit{#1}}

\newcommand{\logequiv}{\mathrel{\Longleftrightarrow}} % Logically equivalent

\DeclareMathOperator*{\minimize}{min} % minimize for linear programs
%%%

\begin{document}

\begin{titlepage}
    \begin{center}
      Міністерство освіти і~науки України\\
      Національний авіаційний університет\\
      Факультет кібербезпеки, комп'ютерної та~програмної інженерії\\
      Кафедра комп'ютеризованих систем управління

      \vspace{\fill}
        Домашнє завдання\\
        з~дисципліни «Системи штучного інтелекту»\\
        на~тему «Прикладні системи штучного інтелекту~— системи, засновані на~знаннях. Поняття інженерії знань»

      \vspace{\fill}

      \begin{flushright}
        Виконав:\\
        студент \allcaps{ФККПІ}\\
        групи \allcaps{СП}-425\\
        Клокун В.\,Д.\\
        Перевірила:\\
        Росінська Г.\,П.
      \end{flushright}

      Київ 2019
    \end{center}
  \end{titlepage}

  \newpage
  \tableofcontents
  \newpage

  \section{Системи, засновані на~знаннях}
    \subsection{Загальні відомості про~системи, засновані на~знаннях}
      В~контексті систем штучного інтелекту, \emph{система, заснована на~знаннях}~— це~програма, яка~намагається вирішувати складні задачі, міркуючи за~допомогою бази знань. Термін «система, заснована на~знаннях» широкий і~може позначати багато різних систем, але~усі~системи, засновані на~знаннях, об'єднує одна спільна тема: спроба явно представити знання, а~також наявність системи міркування, яка~дозволяє виводити нові знання. Отже, у~системи, заснованої на~знаннях, є~дві~визначаючі складові: база знань~(\transeng{knowledge base}) та~машина логічних виведень~(\transeng{inference engine}).

      Крім бази знань та~машини логічних виведень, система, заснована на~знаннях, може містити модулі: підсистему набуття знань, підсистему пояснень та~інтерфейсну підсистему.

      Загалом, систему, засновану на~знаннях, можна описати такою ієрархією рівнів від~найвищого до~найнижчого:
      \begin{hangenumerate}
        \item Рівень знань~(\transeng{knowledge level}).
        \item Рівень символів~(\transeng{symbol level}).
        \item Рівень алгоритмів і~структур даних.
        \item Рівень мов~програмування.
        \item Рівень компонування.
        \item Рівень апаратних засобів.
      \end{hangenumerate}

      Рівень знань пов'язаний зі~змістом інформації, а~також способами її~використання і~визначає можливості інтелектуальної системи. Самі знання не~залежать від~формалізмів, використовуваних для~їхнього подання, а~також виразності обраної мови програмування. На~рівні знань зважуються питання про~те, які~запити є~припустимими в~системі, які~об'єкти і~відношення відіграють важливу роль у~даній предметній області, як~додати в~систему нові знання, чи~будуть факти згодом змінюватися, як~у~системі будуть реалізовані розсуди про~знання, чи~має~дана предметна область добре зрозумілу систематику, чи~є~в~ній~незрозуміла або~неповна інформація.

      Рівень символів пов'язаний з~конкретними формалізмами, застосовуваними для~подання знань у~процесі вирішення задач. На~цьому рівні здійснюється вибір конкретного способу подання знань і~визначається мова подання для~бази знань, зокрема, логічні або~продукційні правила. Відділення рівня символів від~рівня знань дозволяє програмісту вирішувати проблеми виразності, ефективності і~простоти програмування, що~не~відносяться до~більш високих рівнів поводження системи.

      Рівень алгоритмів і~структур даних визначає структури даних для~подання знань і~алгоритми їхньої обробки.

      Рівень мов~програмування визначає використовуваний стиль програмування. Хоча гарний стиль програмування припускає поділ конкретних властивостей мови програмування і~вищестоящих рівнів, специфіка задач штучного інтелекту вимагає їхнього глибокого взаємозв'язку.

      Рівень компонування визначає архітектуру і~функціональність операційної системи.

      Рівень апаратних засобів визначає архітектуру апаратних засобів, обсяг пам'яті~і~швидкодію процесора.

      Багаторівневий підхід дозволяє програмісту відволіктися від~складності, що~відноситься до~нижніх рівнів, і~сконцентрувати свої зусилля на~питаннях, що~відповідають даному рівню абстракції. Такий підхід дозволяє виділити теоретичні основи штучного інтелекту й~абстрагуватися від~деталей конкретної реалізації або~мови програмування. Він~дозволяє модифікувати реалізацію, підвищуючи її~ефективність, або~перенести її~на~іншу платформу, не~торкаючись поводження системи на~більш високих рівнях.

    \subsection{База знань}
      У~базі знань зберігаються факти про~світ, часто представлені за~допомогою категоризації, тобто визначення відношень~«є», на~кшталт «яблуко є~фрукт», або~за~допомогою фреймів, графів концепцій чи~логічних міркувань. Ці~підходи представляють знання у~явній формі, на~відміну від~традиційного неявного представлення знань в~імперативних програмах, де~програміст неявно вкладає свої знання в~програму, вказуючи їй, що~робити. Використання бази знань дозволяє легко визначати нові знання, або~модифікувати і~поповнювати існуючі.

    \subsection{Машина логічних виведень}
      Знання, представлені у~базі, використовуються для~виведення нових знань або~висновків. Для~цього машина логічних виведень застосовує логічні правила до~знань, що~зберігаються у~базі, і~на~їх~основі отримує результат~— розв'язок задачі. Саме вибір методів подання та~одержання знань визначає архітектуру системи знань.

      \subsubsection{Компоненти машини логічних виведень}
        Машина логічних виведень складається з~двох компонентів:
        \begin{hangenumerate}
          \item Компонент висновування~— реалізує власний дедуктивний висновок. Тобто якщо в~базі фактів є~факт~\minttext{A}, а~в~базі правил є~правило \minttext{If A then B}, то~робиться висновок про~необхідність застосування дії~\minttext{B}.
          \item Компонент керування, або~інтерпретатор правил~— керує процесом перебирання фактів і~застосування правил.
        \end{hangenumerate}

        Інтерпретатор правил працює за~таким алгоритмом:
        \begin{hangenumerate}
          \item Зіставлення. Здійснюється пошук множини правил, посилки яких зіставляються хоча б~з~одним фактом із~бази фактів. Усі~правила з~цієї множини є~застосовними до~поточної бази фактів. Якщо правил у~цій~множині більше одного, то~кажуть, що~множина правил є~конфліктною (у~тому розумінні, що~будь-яке~з~правил можна застосувати і~невідомо, яке~саме).
          \item Вибір. Алгоритм роботи інтерпретатора є~циклічним. На~кожній ітерації циклу може бути застосовано лише одне правило. Якщо правил більше одного, інтерпретатор має~вирішити конфлікт, тобто обрати з~правил найвідповідніше. Вибір здійснюється на~основі критерію, який може встановлюватися ззовні.
          \item Виконання. Відібране правило запускається на~виконання (спрацьовує). Суть спрацьовування полягає у~виконанні дії, описаної у~висновку правила. Такими діями можуть бути:
            \begin{hangitemize}
              \item коректування критерію вибору правил;
              \item запис, видалення або~коректування фактів у~базі фактів;
              \item запис, видалення або~коректування фактів у~базі правил;
              \item виконання інших дій~(ведення діалогу з~людиною, перевірка цілісності тощо).
            \end{hangitemize}
        \end{hangenumerate}

      \subsubsection{Стратегії керуванням виведенням}
        Машина логічних виведень має~вирішувати, як~перебирати факти і~правила бази знань, а~також на~підставі якого критерію слід вибирати правила з~конфліктної множини. Відповідні рішення приймаються згідно з~обраною стратегією керування виведенням. Зазвичай основні складові цієї стратегії вбудовані в~машину виведення і~їх~не~можна змінити.

        Розробляючи стратегію керування виведенням, слід вирішити такі питання:
        \begin{hangitemize}
          \item Яку~точку в~просторі станів обрати як~початкову? Від~вибору цієї точки залежить спосіб виконання пошуку — в~прямому чи~зворотному напрямку.
          \item Якою має~бути стратегія перебирання правил — углибину чи~вшир?
        \end{hangitemize}

        Існує декілька стратегій виведення. У~системах з~прямим виведенням за~відомими фактами відшукується факт, який з~них~випливає. Якщо такий факт вдається знайти, то~він~записується в~базу фактів. Пряме виведення називають також виведенням, керованим даними, або~виведенням, керованим посилками правил.

        Під~час~зворотного виведення спочатку висувається гіпотеза, а~потім механізм виведення ніби повертається назад, переходячи до~фактів і~намагаючись знайти в~базі фактів ті, які~підтверджують гіпотезу. Якщо гіпотеза не~підтверджується фактами з~бази фактів, одна з~її~можливих посилок вважається гіпотезою, що~деталізує початкову і~є~стосовно неї~підціллю. Далі відшукуються факти, які~могли б~підтвердити дану підціль, тобто процес рекурсивно повторюється. Виведення цього типу називається також виведенням, керованим цілями.

        Під~час~пошуку вглиб черговою підціллю стає та, що~відповідає детальнішому рівню опису задачі. Виконуючи пошук ушир, машина виведення спочатку спробує знайти розв'язок серед можливих варіантів одного рівня і~потім, за~необхідності, перейде на~наступний рівень деталізації.

        Продукційна модель знімає обмеження, характерні для~логіки, проте з~нею~пов'язані інші пробеми: нескінченні цикли, можлива суперечність знань і~непрозорість поведінки машини виведення.
        Нескінченні цикли виникають у~тому випадку, коли машина виведення повертається до~правил, які~вже~були переглянуті. Це~можливо, наприклад, за~наявності таких правил:
        \begin{codegeneric}
          If A then B; If B then C; If C then A.
        \end{codegeneric}

        Суперечливі знання з'являються тоді, коли додавання нових правил призводить до~суперечності тим~фактам, які~можна було отримати раніше.

        Непрозорість поведінки обумовлена тим, що~немає жодних принципів, які~б~встановлювали порядок перегляду правил і~їхнього застосування в~тому випадку, коли може бути застосовано кілька правил. Унаслідок цього досить важко обробляти всі~продукційні бази знань великого обсягу, оскільки навіть за~умов коректності всіх наявних правил хибний порядок їхнього виконання може привести до~помилок, які~важко виявити.

        Частково зняти обмеження, характерні для~формально-логічної та~продукційної моделей, можна шляхом структуризації бази знань. Названі моделі допускають зображення в~базі знань лише елементарних фактів. Структуризація фактів приводить до~створення груп взаємопов'язаних фактів, тобто певних абстракцій. Структурні абстракції можуть мати свою семантику, щодо якої застосовуються правила виведення. Семантичні мережі та~фрейми, найчастіше використовуються у~моделях, які~підтримують структурні абстракції.

  \section{Поняття інженерії знань}
    Як~видно з~назви, ключовим елементом систем, заснованих на~знаннях, є~знання, тому при~розробці і~дослідженні таких систем з'являється потреба у~дослідженні знань. Цим~займається \emph{інженерія знань}~— розділ теорії штучного інтелекту, який вивчає процеси і~методи одержання, подання і~формалізації знань для~розробки систем, заснованих на~знаннях, зокрема, експертних систем.

    \emph{Набуття знань}~— це~передача потенційного досвіду рішення проблеми від~певного джерела знань і~перетворення його у~вигляд, що~дозволяє використовувати ці~знання.  Джерелами знань можуть бути книги, архівні документи, вміст інших баз~знань і~тому подібне, тобто деякі об'єктивізовані знання, переведені у~форму, що~робить їх~доступними для~споживача. Іншим типом знань є~\emph{експертні знання}, які~є~у~фахівців, але~не~зафіксовані у~зовнішніх стосовно нього сховищах. Експертні знання є~суб'єктивними. \emph{Емпіричні знання}, отримані шляхом спостереження за~навколишнім середовищем, є~ще~одним видом суб'єктивних знань.

    \subsection{Методи витягу знань}
      Введення в~базу знань об'єктивізованих знань не~є~проблемою, однак виявлення і~введення суб'єктивних експертних знань є~досить важким.

      Щоб~витягнути і~формалізувати експертні знання, розробили багато стратегій опитування експертів і~моделей подання знань. Загалом виділяють такі методи витягу знань:
      \begin{hangenumerate}[leftmargin=0em]
        \item \emph{Комунікативні методи}~— охоплюють методи і~процедури контактів інженера зі~знань з~безпосереднім джерелом знань~— експертом. Комунікативні методи поділяються на:
          \begin{hangenumerate}[leftmargin=0em]
            \item \emph{Пасивні методи} включають такі методи, де~ведуча роль у~процедурі витягу фактично передається експерту, а~інженер зі~знань тільки фіксує судження експерта під~час~роботи з~прийняття рішень. До~цієї групи відносяться:
              \begin{hangenumerate}[leftmargin=0em]
                \item \emph{Метод спостереження} полягає в~тому, що~інженер зі~знань знаходиться безпосередньо поруч з~експертом під~час~його професійної діяльності або~імітації цієї діяльності. При~підготовці до~сеансу експерту необхідно пояснити мету спостережень і~попросити його максимально коментувати свої дії; під~час~сеансу аналітик записує всі~дії~експерта і~його пояснення. Рекомендується використовувати магнітофонний запис і~відеозапис у~реальному масштабі часу. Протоколи спостережень після сеансу ретельно розшифровуються, а~потім обговорюються з~експертом.
                \item \emph{Метод протоколювання «думок уголос»} полягає в~тому, що~експерта просять не~тільки прокоментувати свої дії~і~рішення але~й~пояснити, як~це~рішення було знайдено. Іноді цей~метод називають «вербальні звіти». Основними труднощами при~протоколюванні «думок уголос» є~принципова складність для~людини пояснити, як~вона думає, оскільки відомо, що~люди не~завжди здатні достовірно описувати розумові процеси.
                \item \emph{Метод витягу знань у~формі лекцій} використовується при~розробці бази знань як~ефективний метод швидкого занурення інженера зі~знань у~предметну область. Курс лекцій звичайно дуже короткий і~не~перевищує 2–5~лекцій тривалістю до~1,5~години кожна.
              \end{hangenumerate}
            \item \emph{Активні методи} витягу знань припускають, що~ініціатива знаходиться цілком у~руках інженера зі~знань, який активно контактує з~експертом різними способами. Активні методи поділяють на:
              \begin{hangenumerate}
                \item \emph{Індивідуальні активні методи}, а~саме:
                  \begin{hangenumerate}
                    \item \emph{Анкетування} передбачає, що~інженер зі~знань заздалегідь складає запитальник або~анкету, розмножує її~і~використовує для~опитування декількох експертів. Експерт самостійно заповнює анкету після попереднього інструктування.
                    \item \emph{Інтерв'ю}~— специфічна форма спілкування інженера зі~знань і~експерта, у~якій інженер зі~знань задає експерту серію заздалегідь підготовлених питань з~метою витягу знань про~предметну область. На~якість проведення інтерв'ю~впливають три~основних характеристики питання: мова питання (зрозумілість, лаконічність, термінологія), порядок питань (логічна послідовність і~немонотонність), доречність питань (етика, увічливість).
                    \item \emph{Вільний діалог}~— метод витягу знань у~формі бесіди інженера зі~знань і~експерта, у~якій немає твердого регламентованого плану і~запитальника.
                  \end{hangenumerate}
                \item \emph{Групові методи}, які~дають можливість одночасно використати знання декількох експертів, які, взаємодіючи, генерують нову інформацію завдяки тому, що~їх~погляди і~позиції переплітаються. До~групових методів відносяться:
                  \begin{hangenumerate}
                    \item \emph{Метод «круглого столу»} передбачає обговорення якої-небудь проблеми з~обраної предметної області, у~якому беруть участь з~рівними правами кілька експертів. Задача дискусії – колективно, з~різних точок зору, під~різними кутами досліджувати спірні гіпотези предметної області.  Спочатку учасники висловлюються у~визначеному порядку, а~потім переходять до~вільного обговорення.
                    \item \emph{«Мозковий штурм»}~— один з~найбільш розповсюджених методів розкріпачення й~активізації творчого мислення. Основна ідея штурму~— це~відділення процедури генерування ідей у~замкнутій групі фахівців від~процесу аналізу й~оцінювання висловлених ідей. Тривалість «штурму» до~40 хвилин. Учасникам (до~10 осіб) пропонується висловити будь-які~ідеї на~задану тему (критику заборонено). Регламент – до~2 хвилин на~виступ. При~аналізі відповідей лише 10– 15~\% ідей виявляються розумними, але~серед них~можуть бути дуже оригінальні. Оцінює результати група експертів, що~не~брала участь в~генерації ідей.
                    \item \emph{Гра}~— такий вид~людської діяльності, що~відбиває (відтворює) інші її~види. Експертні ігри включають ділові ігри (експеримент, де~учасникам пропонується виробнича ситуація, а~вони на~основі знань і~життєвого досвіду приймають рішення, що~потім аналізуються), діагностичні ігри (вид~ділових ігор, застосовуваний для~діагностики методів прийняття рішень у~медицині) і~комп'ютерні ігри (ігри-дії, симулятори, стратегічні ігри, пригодницькі ігри, рольові ігри).
                  \end{hangenumerate}
              \end{hangenumerate}
          \end{hangenumerate}
      \end{hangenumerate}

    \subsection{Принципи представлення знань}
      Знання, які~були отримані певним способом, необхідно представити, щоб~система могла їх~використовувати. Для~цього три~експерти з~представлення знань Рендал Дейвіс, Говард Шроуб та~Пітер Соловіц розглянули та~проаналізували існуючі передові методи. Вони підсумували свої висновки у~п'яти~базових принципах представлення знань та~їх~ролі в~штучному інтелекті:
      \begin{hangenumerate}
        \item Представлення знань~— це~сурогат. Фізичні об'єкти, події та~відносини, які~не~можна зберігати у~комп'ютері напряму, представляються символами, які~є~сурогатами зовнішніх речей. Ці~символи та~зв'язки між~ними формують модель зовнішньої системи. Маніпулюючи внутрішніми сурогатами, комп'ютерна програма може симулювати зовнішню системи та~робити висновки про~неї.
        \item Представлення знань~— це~набір онтологічних схильностей. Онтологія~— це~наука про~існування. Для~бази даних або~бази знань онтологія визначає категорії речей, які~існують або~можуть існувати у~предметній області. Ці~категорії відображають онтологічні схильності розробника або~інженера знань.
        \item Представлення знань є~середою для~ефективних обчислень. Крім представлення знань, система штучного інтелекту має~закодувати знання у~формі, яку~може ефективно обробити наявне обчислювальне обладнання. Як~зрозумів Лейбніц, деякі найцікавіші задачі можна представити досить просто, але~щоб~їх~вирішити, може знадобитись величезна кількість часу та~зусиль. Нові досягнення в~областях апаратного забезпечення та~теорії програмування сильно впливали на~розробку та~використання мов~представлення знань.
        \item Представлення знань~— це~середа людського вираження. Хороша мова представлення знань повинна сприяти комунікації інженерів представлення знань, які~розуміються на~штучному інтелекті, та~експертів предметної області, які~розуміють застосування системи. Незважаючи на~те, що~інженери представлення знань створюють визначення та~правила, експерти предметної області повинні мати змогу читати їх~та~перевіряти, чи~дійсно вони представляють реалістичну теорію предметної області.
      \end{hangenumerate}

  \clearpage
  \section{Висновок}
    Виконуючи дане домашнє завдання, були досліджені системи штучного інтелекту, засновані на~знаннях~— системи, які~намагаються логічно міркувати, використовуючи внесені в~неї~знання, щоб~вирішувати поставлені перед ними задачі. Так~як~система покладається на~внесені в~неї~знання, щоб~робити логічні виведення, перш за~все~необхідно наповнити її~знаннями з~предметної області. Для~цього треба представити їх~у~формі, зрозумілій цій~системі. Представленням знань займається спеціальна галузь досліджень штучного інтелекту~— інженерія знань, яка~визначає методи витягнення знань з~предметної області, а~також принципи і~форми їх~представлення.

    Після витягнення і~представлення знань у~певній формі, вони знаносяться в~один з~двох найважливіших компонентів систем, заснованих на~знаннях,~— базу даних. Саме на~базу даних покладається другий найважливіший компонент~— машина логічних виведень, яка~відповідає за~обробку існуючих знань таким чином, щоб~з~їх~допомогою вирішити поставлену задачу. Вона шукає в~базі даних релевантну інформацію за~допомогою однієї з~декількох описаних стратегій, аналізує її~та~представляє розв'язок поставленої задачі.

    Крім двох вищезазначених визначальних компонентів систем, заснованих на~знаннях, вони можуть містити такі модулі як~підсистему набуття знань, підсистему пояснень та~інтерфейсну підсистему.

    Підсистема набуття знань дає~можливість системі набувати нові знання за~допомогою власних інструментів на~кшталт навчання під~наглядом, тобто машинного або~глибокого навчання, або~ж~звичайного додавання нових знань у~базу даних.

    Підсистема пояснень дозволяє визначати, як~і~чому машина логічних виведень прийшла до~отриманого рішення. Це~корисно для~налагодження системи, а~також дозволяє експертам предметної області звернути увагу на~досі не~знайдені зв'язки між~знаннями, які~були внесені у~базу даних.

    Інтерфейсна підсистема відповідає за~обмін інформацією між~системою та~її~користувачам або~оператором. Оскільки головна система найбільше спирається на~внесені в~неї~знання, то~для~пошуку правильного розв'язку або~прийняття оптимального рішення важливо, щоб~у~систему надходила якісна і~доступно представлена інформація про~задачу, які~необхідно вирішити. Тому інтерфейсна система намагається зробити введення даних задачі якомога зручнішим.

    Отже, завдяки виконанню домашнього завдання, ми~детальніше ознайомились із~системами штучного інтелекту, зокрема з~системами, заснованими на~знаннях, а~також ознайомились із~поняттям та~основними відомостями інженерії знань.

  \clearpage
  \section{Список використаної літератури}
  \begin{litlist}
    \item \textit{Субботін С.\,О.} Подання й~обробка знань у~системах штучного інтелекту та~підтримки прийняття рішень: Навчальний посібник. —~Запоріжжя: \allcaps{ЗНТУ}, 2008. —~341~с.
    \item \textenglish{\textit{Sowa, John F.} Knowledge Representation. Logical, Philosophical and Computational Foundations. —~Pacific Grove: Brooks/Cole, 2000}. —~594~с.
  \end{litlist}
  % \printbibliography

\end{document}
